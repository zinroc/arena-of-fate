"use strict";

var Promise = Promise || require("bluebird");

var Challenge = function (obj) {
    for (var k in obj) {
        if (obj.hasOwnProperty(k)) {
            this[k] = obj[k];
        }
    }
};

module.exports = function (knex) {
    "use strict";
    var challengeStore = {
        /**
        * Return challenge or match by ID
        */
        read: function (challengeID) {
            return knex("arena_challenges").select("*")
            .where("id", challengeID).then(function(rows) {
                if (rows.length === 0) {
                    return null;
                } else {
                    return rows[0];
                }
            });
        },

        /**
         * Return an array of all pending challenges for given player as a promise
         */
        getPending: function (email) {
            return knex("arena_challenges").select("arena_challenges.id AS id", "arenas.name AS arena_name", "fighters.name AS fighter_name", "arena_challenges.status AS status",
                    "fighters.fame AS fighter_fame", "fighters.num_wins AS fighter_num_wins", "fighters.num_losses AS fighter_num_losses", "entry_fee", "winner_prize", "min_fame",
                    "arena_challenges.timestep_scheduled")
            .where({ player: email, "arena_challenges.status": "pending" })
            .innerJoin("arenas", "arena_challenges.arena", "arenas.id")
            .innerJoin("fighters", "arena_challenges.arena_fighter", "fighters.id")
            .then(function (rows) {
                return rows;
            });
        },
        /**
         * Return an array of all challenges accepted by given player, as a promise
         */
        getAccepted: function (email) {
            return knex("arena_challenges").select("arena_challenges.id AS id", "arenas.name AS arena_name", "fighters.name AS arena_fighter_name", "fighters.fame AS arena_fighter_fame",
                    "arena_challenges.status AS status", "arena_challenges.random_seed AS random_seed",
                    "arena_challenges.player_fighter AS player_fighter_id", "arena_challenges.timestep_scheduled AS timestep_scheduled",
                    "fighters.num_wins AS fighter_num_wins", "fighters.num_losses AS fighter_num_losses", "arena_challenges.winner_prize AS winner_prize")
            .where({ "player": email, "arena_challenges.status": "accepted" })
            .innerJoin("arenas", "arena_challenges.arena", "arenas.id")
            .innerJoin("fighters", "arena_challenges.arena_fighter", "fighters.id")
            .then(function (rows) {
                return rows;
            });
        },
        /**
         * Return an array of all matches scheduled for given timestep for the current player, as a promise
         * Also challenges
         */
        getMatchesOnTimestep: function (email, timestep) {
            return knex("arena_challenges")
                .select("*")
                .where({ player: email, timestep_scheduled: timestep });
        },
        /**
         * Return an array of all challenges for the player, resolved or not, as a promise
         */
        getAll: function (email) {
            return knex("arena_challenges").select("arena_challenges.id AS id", "arenas.name AS arena_name", "fighters.name AS arena_fighter_name",
                    "arena_challenges.player_fighter AS player_fighter_id", "arena_challenges.status AS status",
                    "fighters.num_wins AS fighter_num_wins", "fighters.num_losses AS fighter_num_losses", "arena_challenges.winner_prize AS winner_prize")
            .where({ "player": email })
            .innerJoin("arenas", "arena_challenges.arena", "arenas.id")
            .innerJoin("fighters", "arena_challenges.arena_fighter", "fighters.id")
            .then(function (rows) {
                return rows;
            });
        },
        /**
        * Update the status and the winner of a match
        * Also can be used to add player fighter and winner_prize
        */
        update: function (match) {
            return knex("arena_challenges").where("id", match.id)
            .update({ status: match.status, winner: match.winner, player_fighter: match.player_fighter, winner_prize: match.winner_prize })
            .then(function (r) {
                return r;
            });
        },
        /**
         * Create a challenge, issued by the given arena with the given fighter
         * Assume fighter and arena already exist
         * @param email is the email of the person to whom the challenge is offered
         *
         * Return promise which gives insert ID
         */
        create: function (challenge) {
            return knex("arena_challenges")
            .insert(challenge)
            .returning("id")
            .then(function (idArray) {
                return idArray[0];
            });
        },
        /**
         * Same as create, but creates multiple challenges and return array of IDs
         * Actually returns promise to array
         */
        createMany: function (challenges) {
            var promises = [];
            for (var i = 0; i < challenges.length; i++) {
                promises.push( challengeStore.create(challenges[i]) );
            }
            return Promise.all(promises);
        },
        /**
         * Return promise which resolves to true on success and false on failure
         * Failure is when challengeID is not valid
         */
        decline: function (challengeID) {
            return knex("arena_challenges").update({ status: "declined" })
            .where("id", challengeID)
            .then(function (numRowsAffected) {
                return numRowsAffected > 0;
            });
        },
        /**
         * Decline all the challenges given
         * The challenges are given as an array of IDs
         * Returned is a promise when all challenges are declined
         * Return value is promise to an array of true/false for success of each operation
         */
        declineAll: function (challengeIDArray) {
            var promises = [];
            for (var i = 0; i < challengeIDArray.length; i++) {
                promises[i] = challengeStore.decline(challengeIDArray[i]);
            }
            return Promise.all(promises);
        },
        /**
         * Delete all challenges for the given player
         * Return a promise
         */
        deleteAll: function (email) {
            return knex("arena_challenges")
            .where("player", email).del().then(function (r) {
                return r;
            });
        },
        /**
         * Return a promise to all expired challenges
         */
        getExpired: function (timestep) {
            return knex("arena_challenges")
            .where("timestep_scheduled", "<", timestep)
            .select("*").then(function (rows) {
                return rows;
            });
        },
        /**
         * Decline all challenges which are currently pending, <= current timestep (which is provided)
         */
        declinePending: function (timestep) {
            return knex("arena_challenges")
            .where("timestep_scheduled", "<=", timestep)
            .andWhere ("status", "pending")
            .update({ status: "declined" })
            .then (function (r) {
                return r;
            });
        },
        /**
         * Decline all challenges which are currently accepted, <= current timestep (which is provided)
         */
        declineAccepted: function (timestep) {
            return knex("arena_challenges")
            .where("timestep_scheduled", "<=", timestep)
            .andWhere ("status", "accepted")
            .update({ status: "declined" })
            .then (function (r) {
                return r;
            });
        },
        /**
        * itterate through arenas, get all pending records and find one with highest value
        */
        updateWinningRecords: function (timestep) {
            var arenas = [];
            var topAttendance = [];
            //get all arenas
            return knex("arenas").select("*")
            .then(function (arenasArr){
                arenas = arenasArr;

                //get top attendance scores for each arena at given timestep
                var promises = [];
                for (var i=0; i<arenas.length; i++){
                    promises[i] = knex("arena_records").select("*")
                    .where("name", "attendance")
                    .andWhere("arena", arenas[i].id)
                    .andWhere("timestep", timestep)
                    .orderBy("value", "desc").limit(1);
                }
                return Promise.all(promises);
            }).then(function (topAttendanceArr){
                if (!topAttendanceArr.length){
                    //this happens if there are no arenas
                    return false;
                } else {
                    for (var i=0; i<topAttendanceArr.length; i++){
                        if (topAttendanceArr[i].length){
                            topAttendance[i] = topAttendanceArr[i][0];
                        } else {
                            topAttendance[i] = false;
                        }
                    }
                    var promises = [];

                    //offer record holders who have the highest score the reward
                    for (var i=0; i<topAttendance.length; i++){
                        if (topAttendance[i]){
                            promises[i] = knex("record_holders")
                            .where("record", topAttendance[i].id)
                            .andWhere("status", "pending")
                            .update("status", "offered");
                        }
                    }
                    var j=i;
                    //bots auto accept the reward
                    for (var i=0; i<topAttendance.length; i++){
                        if (topAttendance[i]){

                            promises[j] = knex("record_holders")
                            .where("record", topAttendance[i].id)
                            .andWhere("status", "void")
                            .update("status", "accepted");
                            j++;
                        }
                    }

                    return Promise.all(promises);
                }
            }).then(function (){
                //delete all non-winning record_holders

                return knex("record_holders")
                .where( function () {
                    this.where("status", "pending").orWhere("status", "void")
                }).del();

            }).then(function (){
                return 'yes';
            });
        },

        /**
         * Return promise to all challenges which are scheduled for given timestep
         */
        getScheduled: function (timestep) {
            return knex("arena_challenges")
            .where("timestep_scheduled", timestep)
            .andWhere ("status", "accepted")
            .select("*").then(function (rows) {
                return rows;
            });
        },
        /**
         * Return all unexpired challenges for the player
         */
        getUnexpired: function (email, timestep) {
            return knex("arena_challenges")
            .where("timestep_scheduled", ">=", timestep)
            .andWhere("player", email)
            .select("*");
        },
        /**
         * Return true iff the given fighter is available to fight on the given timestep
         */
        fighterIsAvailable: function (fighter, timestep) {
            return knex("arena_challenges")
            .where("player_fighter", fighter)
            .andWhere("timestep_scheduled", timestep)
            .select("id").then (function (rows) {
                return rows.length === 0;
            });
        },
    };

    return challengeStore;
};
