var Promise = Promise || require("bluebird");

module.exports = function (knex) {
    this.knex = knex;

    var fighterStore = {
        /**
         * Return fighter by ID (actually return promise)
         */
        read: function (fighterID) {
            return knex("fighters").select("*")
            .where("id", fighterID).then(function (rows) {
                if (rows.length > 0) {
                    return rows[0];
                } else {
                    return null;
                }
            });
        },
        getSkills: function (char_id) {
            return knex("character_skills").select("*")
            .where("character", char_id);
        },
        getStrategyExperience: function (char_id){
            return knex("strategy_experience").select("*")
            .where("character", char_id);
        },
        /**
         * Returns an array of all living fighters belonging to given player (email)
         * Returns promise to array
         */
        getLiving: function (email) {
            return knex("fighters").select("*")
            .where("email", email)
            .andWhere("status", "<>", "killed")
            .orderBy("fame", "desc");
        },
        /**
         * Save the given fighter in the DB (first time - new fighter)
         * Returns promise to ID
         */
        save: function (fighter, email) {
            fighter.email = email;
            return fighterStore.initFighterTrait(fighter)
            .then(function () {
                if (fighter.hasOwnProperty("skills")) {
                    delete (fighter.skills);
                }
                return knex("fighters")
                .insert(fighter)
                .returning("id");
            }).then(function (result) {
                fighter.id = result[0];
                return fighterStore.saveFighterArt(fighter);
            }).then(function () {
                return fighterStore.saveFighterStrategyExperience(fighter);
            }).then(function () {
                return fighterStore.initFighterSkills(fighter);
            }).then(function () {
                return fighterStore.saveFighterSkills(fighter);
            }).then(function () {
                return fighterStore.saveFighterTechCond(fighter);
            }).then(function () {
                return fighter.id;
            });
        },
        /**
         * saves additional parameters required for bots - their plan 1 techniques
         * Returns promise to ID
         */
        saveBot: function (fighter_id, email) {
            var slots = ['slot_1', 'slot_2', 'slot_3', 'ultimate'];

            //needs to be in order, otherwise may have duplicate techniques in slots 1-3

            return fighterStore.pickTechForSlot(fighter_id, 'slot_1').then(function (){
                return fighterStore.pickTechForSlot(fighter_id, 'slot_2');
            }).then(function(){
                return fighterStore.pickTechForSlot(fighter_id, 'slot_3');
            }).then(function(){
                return fighterStore.pickTechForSlot(fighter_id, 'ultimate');
            }).then(function (){
                return knex("fighters")
                .where("id", fighter_id)
                .update("bot", true);
            }).then(function (){
                return 'yes';
            });

        },
        pickTechForSlot: function (fighter_id, slot) {
            var promises = [];
            var whereData = {};
            var fighter = {};
            var stratExp = {};
            var technique = {};
            var planTech = {};
            return knex("fighters").select("*").where("id", fighter_id)
            .then(function (fighterArr){
                fighter = fighterArr[0];
                return knex("strategy_experience").select("*")
                .where({rank: '1', character: fighter.id});
            }).then(function (stratExpArr){
                stratExp = stratExpArr[0];
                return knex("plan_techniques").select("*")
                .where("plan", stratExp.id);
            }).then(function (planTechArr){
                planTech = planTechArr[0];

                if (slot !== "ultimate"){
                    return knex("techniques").select("*")
                    .whereNotIn('id', [planTech.slot_1, planTech.slot_2, planTech.slot_3, planTech.ultimate])
                    .andWhere(function(){
                        this.where('trait', fighter.trait).orWhere('strategy', stratExp.strategy)
                    })
                    .andWhere('ultimate', false)
                    .orderByRaw('RANDOM()')
                    .limit(1);
                } else {
                    return knex("techniques").select("*")
                    .whereNotIn('id', [planTech.slot_1, planTech.slot_2, planTech.slot_3, planTech.ultimate])
                    .andWhere(function(){
                        this.where('trait', fighter.trait).orWhere('strategy', stratExp.strategy)
                    })
                    .andWhere('ultimate', true)
                    .orderByRaw('RANDOM()')
                    .limit(1);
                }
            }).then(function (techArr){
                technique = techArr[0];

                return knex("plan_techniques")
                .where("plan", stratExp.id)
                .update(slot, technique.id);
            }).then(function (){
                return 'yes';
            });
        },
        saveFighterArt: function (fighter){
            return knex("character_art").select("*")
            .then(function (artArr){
                var randomIndex = Math.floor(Math.random() * artArr.length);
                var updateData = {
                    art: artArr[randomIndex].portrait,
                    body_art: artArr[randomIndex].body
                };
                return knex("fighters").where("id", fighter.id).update(updateData);
            });
        },
        saveFighterStrategyExperience: function (fighter) {
            return knex("strategies").select("*")
            .then(function (stratArr) {
                var strat_rows = [];
                for (var i = 0; i < stratArr.length; i++) {
                    var strat = stratArr[i];
                    strat_rows[i] = {
                        strategy: strat.id,
                        experience_as: Math.round(Math.random() * 100),
                        experience_against: Math.round(Math.random() * 100),
                        character: fighter.id
                    };
                }
                strat_rows.sort(function (row1, row2) {
                    return row2.experience_as - row1.experience_as;
                });
                for (var i = 0; i < 3; i++) {
                    strat_rows[i].rank = i + 1;
                }

                var promises = [];
                for (var i = 0; i < strat_rows.length; i++) {
                    promises[i] = fighterStore.createStrategyRow(strat_rows[i]);
                }
                return Promise.all(promises);
            });
        },
        createStrategyRow: function (row) {
            return knex("strategy_experience")
            .insert(row)
            .returning("id")
            .then(function(stratID) {
                // each plan needs an entry in plan_techniques, other values can be null
                if (row.rank) {
                    return knex("plan_techniques").insert({
                        plan: stratID[0],
                        slot_1: 0,
                        slot_2: 0,
                        slot_3: 0,
                        ultimate: 0,
                    });
                }
            });
        },
        initFighterSkills: function (fighter) {
            return knex("skills").select("*")
                .then(function (skillsArr) {
                    fighter.initSkills(skillsArr);
                    return fighter;
                });
        },
        /**
         * Return true/false if statement happened (rather a promise to that)
         */
        updateTechSlot: function (email, slot, tech_id, stratExp_id) {

            var slots = ['slot_1', 'slot_2', 'slot_3', 'ultimate'];
            var promises = [];
            for (var i=0; i<slots.length; i++){
                var currentSlot = slots[i];

                var data = {
                    plan: stratExp_id
                };
                data[currentSlot] = tech_id;

                var promise = knex("plan_techniques").where(data).update(currentSlot, null);
                promises.push(promise);

            }

            return Promise.all(promises)
            .then(function () {
                return knex("plan_techniques")
                .where('plan', stratExp_id)
                .update(slot, tech_id);
            }).then(function () {
                return true;
            }).error(function (e) {
                console.error(e);
                return false;
            });
        },
        saveFighterSkills: function (fighter) {
            var promises = [];
            for (var skill in fighter.skills) {
                if (fighter.skills.hasOwnProperty(skill)) {
                    var promise = knex("character_skills").insert({
                        character: fighter.id,
                        skill: skill,
                        value: fighter.skills[skill]
                    });
                    promises.push(promise);
                }
            }
            return Promise.all(promises);
        },
        /**
        *   Fills out the technique_conditioning table for a fighter
        */
        saveFighterTechCond: function (fighter){
            var promises = [];

            return knex("techniques").select("*").whereNot("id", 0)
            .then(function (techArr){
                for (var i=0; i<techArr.length; i++){
                    var value = Math.floor(Math.random()*101);
                    var promise = knex("technique_conditioning").insert({
                        character: fighter.id,
                        technique: techArr[i].id,
                        conditioning: value
                    });
                    promises.push(promise);
                }
                return Promise.all(promises);
            });
        },
        initFighterTrait: function (fighter) {
            return knex("traits")
                .select("*")
                .whereNotNull("description")
                .then(function (traitsArr) {
                    var i = Math.floor(Math.random() * traitsArr.length);
                    var trait = traitsArr[i];
                    fighter.trait = trait.id;
                    return fighter;
                });
        },
        /**
         * Returns promise
         */
        delete: function (fighterID) {
            return knex("fighters")
            .where({ id: fighterID }).update({ status: "killed" }).then(function (r) {
                return r;
            });
        },
        /**
         * Returns promise
         */
         update: function (fighter) {
            // difference from save is cannot change email or name, and ID stays same
            return knex("fighters").update({ fame: fighter.fame, num_wins: fighter.num_wins, num_losses: fighter.num_losses, title: fighter.title })
            .where({ id: fighter.id })
            .then(function (result) {
                return result;
            });
        },
        /**
         * Returns promise
         */
        deleteAll: function (email) {
            return knex("fighters")
            .where("email", email).del().then(function (r) {
                return r;
            });
        }
    };

    return fighterStore;
};
